# -*- coding: utf-8 -*-
"""FloodSimGPT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a25u6o9GD1bJOawbueKTgd99Jmj_rG3B

####**Summary so far**

I have created 3 zones(**A,B,C**) and 3 subzones each within them(**'A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'**). The criteria to determine if the zone is **'safe' , 'at risk' or 'flooded'** are
**water_level,people_trapped, medics, boats and food_packs** . I then increment the situation by 2 steps and which changes the parameters, in turn updating the status of the areas. I generated the summary report. Then, I implemented rule based logic to determine what parameters should be deployed in **flooded** areas to control the flooding. I plan to compare this suggestion with the suggestion given by the LLM. Currently, I am facing difficulty in getting response from the LLM and would need more time for it and later fine tune the rule based logic  and try LLM with different models
"""

import random
import pandas as pd

# Create 3x3 Grid Zones
zones = ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']

# Initialize zone status
zone_state = {
    zone: {
        'water_level': random.randint(0, 2),     # 0 = dry, 1 = light, 2 = flooded
        'people_trapped': random.randint(0, 50),
        'medics': 0,
        'boats': 0,
        'food_packs': 0,
        'status': 'safe'  # could be 'safe', 'at-risk', 'flooded'
    } for zone in zones
}

# Display initial state
df = pd.DataFrame.from_dict(zone_state, orient='index')
print("Initial Flood Map:")
print(df)

# Function to simulate flood rising
def simulate_flood(state, time_step):
    print(f"\n--- Time Step {time_step}: Flood Progression ---")
    for zone, data in state.items():
        if random.random() < 0.5:  # 50% chance flood worsens
            data['water_level'] = min(data['water_level'] + 1, 3)
            data['people_trapped'] += random.randint(0, 20)
        # Update status
        if data['water_level'] >= 3:
            data['status'] = 'flooded'
        elif data['water_level'] == 2:
            data['status'] = 'at-risk'
        else:
            data['status'] = 'safe'
    return state

# Simulate 3 time steps
for t in range(1, 4):
    zone_state = simulate_flood(zone_state, t)
    df = pd.DataFrame.from_dict(zone_state, orient='index')
    display(df)

def generate_flood_summary(zone_state):
    report = "Current Flood Situation Report:\n"
    for zone, data in zone_state.items():
        report += (
            f"- Zone {zone}: Status - {data['status'].upper()}, "
            f"Water Level - {data['water_level']}, "
            f"People Trapped - {data['people_trapped']}, "
            f"Boats - {data['boats']}, "
            f"Medics - {data['medics']}, "
            f"Food Packs - {data['food_packs']}\n"
        )
    return report

# Generate the flood report summary
flood_report = generate_flood_summary(zone_state)

# Display the report
print(flood_report)

"""**Implementing rule based AI**"""

from collections import defaultdict

def rule_based_response_weighted(zone_state, boats=4, medics=4, food_packs=4):
    response = defaultdict(lambda: {"boats": 0, "medics": 0, "food_packs": 0})

    # Step 1: Calculate weights based on people Ã— water level
    zone_weights = {}
    total_weight = 0
    for zone, data in zone_state.items():
        weight = data['people_trapped'] * (data['water_level'] + 1)  # +1 to give dry zones minimal weight
        zone_weights[zone] = weight
        total_weight += weight

    if total_weight == 0:
        return dict(response)  # no need if no one is affected

    # Step 2: Allocate resources proportionally (floating)
    boat_alloc = {z: (zone_weights[z] / total_weight) * boats for z in zone_weights}
    medic_alloc = {z: (zone_weights[z] / total_weight) * medics for z in zone_weights}
    food_alloc = {z: (zone_weights[z] / total_weight) * food_packs for z in zone_weights}

    # Step 3: Round down all and track remaining
    remaining_boats = boats
    remaining_medics = medics
    remaining_food = food_packs

    for z in zone_weights:
        b = int(boat_alloc[z])
        m = int(medic_alloc[z])
        f = int(food_alloc[z])
        response[z]["boats"] = b
        response[z]["medics"] = m
        response[z]["food_packs"] = f
        remaining_boats -= b
        remaining_medics -= m
        remaining_food -= f

    # Step 4: Distribute leftover resources to top-weighted zones
    sorted_zones = sorted(zone_weights.items(), key=lambda x: x[1], reverse=True)

    for z, _ in sorted_zones:
        if remaining_boats > 0:
            response[z]["boats"] += 1
            remaining_boats -= 1
        if remaining_medics > 0:
            response[z]["medics"] += 1
            remaining_medics -= 1
        if remaining_food > 0:
            response[z]["food_packs"] += 1
            remaining_food -= 1
        if remaining_boats == 0 and remaining_medics == 0 and remaining_food == 0:
            break

    return dict(response)

rule_based = rule_based_response_dict(zone_state)
print(rule_based)

"""**Using open source LLM**"""

!pip install -q transformers accelerate bitsandbytes

from transformers import pipeline

generator = pipeline(
    "text-generation",
    model="tiiuae/falcon-7b-instruct",
    device_map="auto",
    torch_dtype="auto"
)

# Build the prompt
prompt = (
    "You are a flood disaster response AI.\n"
    "Your job is to allocate the following resources:\n"
    "- 4 boats\n- 4 medics\n- 4 food packs\n"
    "Use ONLY this format in your response (JSON):\n"
    "{\n"
    '  "A1": {"boats": 1, "medics": 0, "food_packs": 1},\n'
    '  "B3": {"boats": 2, "medics": 1, "food_packs": 0},\n'
    "  ...\n"
    "}\n\n"
    "Here is the flood situation:\n"
    f"{flood_report}\n"
    "Respond only with JSON. Do not add explanations.\n"
)

llm_response = generator(prompt, max_new_tokens=300, temperature=0.7)[0]['generated_text']
print("ðŸ§  Falcon LLM Response:\n")
print(llm_response)

"""1) Improve the data set and inlcude more paramters
2)fine tune the model
3)use neural network
"""



















